*tSkeleton.txt*              tSkeleton -- File Templates and Code Skeletons

Author: Thomas Link, samul AT web.de

-----------------------------------------------------------------------
                                                    *tSkeleton-install*
Install~

Extract tSkeleton.zip (or copy the contained files) to your local 
vimfiles directory (see also |add-global-plugin|) so that you get: >

    (Linux etc.) $HOME/.vim/
    (Windows) $VIM/vimfiles/
        doc/ etc/ plugin/ skeletons/ skeletons/bits/...
        skeletons/prefab/ skeletons/bits.samples/...

The files in the "prefab" and "bits.samples" subdirectories are part of 
the distribution. Copy them to their proper places and adjust them to 
your needs:

    skeletons/
        FILE TEMPLATES ...
        bits/
            general/
                GENERAL CODE SKELETONS ...
            &filetype/
                FILETYPE SPECIFIC CODE SKELETONS ...

When updating from an older version, you might want to backup your 
skeletons beforehand. If you re-use skeletons from version 1.0 with a 
later version, you have to update the |tSkeleton-place-holder| markup.

Then run >

(Linux etc.) >
    :helptags $HOME/.vim/doc

(Windows) >
    :helptags $VIM/vimfiles/doc

You might want to use imaps.vim's (vimscript #244 or vimscript #475) place 
holders in conjunction with template bits.

                                                    *tSkeleton-uninstall*
Uninstalling tSkeleton requires deleting the files from the archive by hand. 
Alternatively, you can feed the file etc/tSkeleton.lst to rm: >
    
    cd $HOME/.vim/
    rm -i `cat etc/tSkeleton.lst`

Some aspects were originally inspired by vimscript #982.


-----------------------------------------------------------------------
                                                    *tSkeleton-usage*
File templates~

The file skeletons are stored in the skeletons subdirectory. Filling in 
a skeleton when creating a new file is controlled by |:autocmd|. This 
provides greater flexibility than a &filetype based approach.

Currently, the following file types are supported by default:

   - batch.bat
   - deplate.txt
   - latex.tex
   - php.inc.php
   - php.php
   - plugin.vim
   - ruby.rb
   - shell.sh
   - text.txt

In order to add a new mode, save a skeleton file to 
~/.vim/skeletons/file.suffix and add something like this to your .vimrc 
file: >

    autocmd BufNewFile *.suffix       TSkeletonSetup template.suffix
    autocmd BufNewFile /here/*.suffix TSkeletonSetup othertemplate.suffix

                                                    *tSkeleton-place-holder*
In skeleton files, you can use the following tags:

    <+FILE NAME ROOT+> :: the file name root
    <+FILE NAME+>      :: the file name
    <+FILE SUFFIX+>    :: the file suffix
    <+FILE DIRNAME+>   :: the file's directory
    <+NOTE+>           :: a note
    <+DATE+>           :: the current date (the format is controlled via 
                          g:tskelDateFormat)
    <+AUTHOR+>         :: the author's name (g:tskelUserName)
    <+EMAIL+>          :: the author's e-mail (g:tskelUserEmail)
    <+WEBSITE+>        :: the author's homepage (g:tskelUserWWW)
    <+LICENSE+>        :: the name of the license this file is released 
                          under (g:tskelLicense)
                          
In order to define your own tag, you have to define a function called 
TSkeleton_TAGNAME() that returns the text to be filled in.

tSkeleton also supports the following pseudo-tags:

    <+CURSOR+>         :: where to place the cursor after insertion
    <+&NAME+>          :: a vim option
    <+g:NAME+>         :: a global variable
    <+b:NAME+>         :: a buffer local variable
    <+?QUERY?+>        :: query the user[1]
    <+?VAR|QUERY?+>    :: query the user and propose some choices from 
                          the variable b:tskelChoices_{VAR} (separated by 
                          "\n")[1]
    <+bit:BIT>, <+bit:BIT|"DEFAULT">, <+bit:BIT|COMMANDS> :: insert a 
                          bit; if the bit isn't defined for the current 
                          filetype, use DEFAULT; if DEFAULT matches ".*" 
                          insert it as a string; otherwise interpret it 
                          as a command sequence to be fed to normal
    <+call:FUNCTION(ARGS)+> :: insert the result value of some function

[1] If the query ends with a colon, the second question mark will be 
removed.

Check out the "test_tSkeleton" skeleton for examples.


                                                    *tSkeleton-modifiers*
Tags can be modified using modifiers, like in: >

    <+TAG NAME:MODIFIER+>

Known modifiers:

    l          :: lower case
    u          :: upper case
    c          :: capitalize
    C          :: transform to CamelCase
    s/FROM/TO/ :: replace text (actually a s//g); this has to come last; 
                  the pattern separator can be selected arbitrarily

Example for a ruby class template: >

    class <+FILE NAME ROOT:cs*\W*_*+>
        <+CURSOR+>
    end

-----------------------------------------------------------------------
                                                    *tSkeleton-code-skeletons*
Code Skeletons~

Smaller skeleton bits are stored in SKELETONS/bits/FILETYPE/ or 
SKELETONS/bits/general/. I.e., code skeletons can be filetype specific 
or generally available.

Skeleton bits can be filled in by typing: >

    :TSkeletonBit NAME

For this command, command line completion is implemented. Calling this 
command will insert the contents of the respective file below the 
current line.

                                                    *tSkeleton-key-bindings*
The default key bindings for inserting code skeletons are:

    <Leader>#  ... Expand name under cursor
    <Leader>## ... Expand name under cursor
    <Leader>#t ... Insert code skeleton via command line

                                                    *tSkeleton-embedded-code*
Code skeletons may contain vim code that is evaluated before or after 
expanding the tags. The before/after blocks are fed to |:exec| and must 
not contain function definitions.

BibTeX example: >

    <tskel:before>
    let b:tskelArticleID = input("ID of bibentry: ")
    if b:tskelArticleID == "" | let b:tskelArticleID = "<+CURSOR+>" | endif
    </tskel:before>
    <tskel:after>
    unlet b:tskelArticleID
    </tskel:after>
    @INCOLLECTION{<+b:tskelArticleID+>,
        author   = {<+CURSOR+>},
        title    = {<+ARTICLE TITLE+>},
        crossref = {<+CROSSREF+>},
        pages    = {<+PAGES+>},
        abstract = {[[~/Projects/Sci/Abstracts/<+b:tskelArticleID+>.txt]]},
    }
    <++>

In the above example, we query the user for an ID and insert this ID as 
entry key and as an abstract's file name.

The before/after blocks are evaluated in the destination buffer. The 
variants here_before/here_after are evaluated in the scratch buffer for 
the current code skeleton.

-----------------------------------------------------------------------
                                                    *tSkeleton-commands*
Commands~
                                                    *:TSkeletonNewFile*
:TSkeletonNewFile ?template, ?destDir, ?destFileName

                                                    *:TSkeletonEdit*
:TSkeletonEdit ?skelDir

                                                    *:TSkeletonBit*
:TSkeletonBit NAME


-----------------------------------------------------------------------
                                                    *tSkeleton-utilities*
Utilities~

                                                    *TSkeletonIncreaseRevisionNumber()*
The function TSkeletonIncreaseRevisionNumber() provides a way to 
automatically update a revision number in the form >

    @Revision: 1.0.126

In order to use this function, add something like this to your |vimrc| 
file: >

    autocmd BufWritePre * call TSkeletonIncreaseRevisionNumber()

                                                    *:TSkeletonCleanUpBibEntry*
The TSkeletonCleanUpBibEntry command can be used to purge the current bibtex 
entry from expendable fields (i.e., lines matching <+.\{-}+>).

For bibtex files, this command is bound to: <Leader>tc

                                                    *TSkeletonMapGoToNextTag()*
                                                    *TSkeletonGoToNextTag()*
If you don't want to install imaps.vim, this function will map <c-j> to 
TSkeletonGoToNextTag() in order to easily jump between tags.

